import asyncio
import logging
import aiohttp
import random
import sqlite3
from aiogram import Bot, Dispatcher, types, F
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

BOT_TOKEN = "8001915500:AAHdXl_wttVRdLWxC9W2N85SZKBDbEW_O0U"


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
def init_db():
    conn = sqlite3.connect('favorites.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS favorites (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            character_id INTEGER NOT NULL,
            character_name TEXT NOT NULL,
            character_image TEXT NOT NULL,
            comment TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()


def add_favorite(user_id, character_id, character_name, character_image, comment):
    conn = sqlite3.connect('favorites.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO favorites (user_id, character_id, character_name, character_image, comment)
        VALUES (?, ?, ?, ?, ?)
    ''', (user_id, character_id, character_name, character_image, comment))
    conn.commit()
    conn.close()


def get_favorites(user_id):
    conn = sqlite3.connect('favorites.db')
    cursor = conn.cursor()
    cursor.execute('''
        SELECT character_name, character_image, comment 
        FROM favorites 
        WHERE user_id = ?
        ORDER BY timestamp DESC
    ''', (user_id,))
    favorites = cursor.fetchall()
    conn.close()
    return favorites


class FSMComment(StatesGroup):
    wait_comment = State()
    character_data = State()


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
init_db()

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
main_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üé≤ –†–∞–Ω–¥–æ–º–Ω—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂")],
        [KeyboardButton(text="‚≠êÔ∏è –ò–∑–±—Ä–∞–Ω–Ω–æ–µ")]
    ],
    resize_keyboard=True
)


async def get_random_character():
    try:
        character_id = random.randint(1, 826)
        url = f"https://rickandmortyapi.com/api/character/{character_id}"

        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
            async with session.get(url) as response:
                if response.status == 200:
                    return await response.json()
                return None
    except Exception as e:
        logger.error(f"Error fetching character: {e}")
        return None


# –ö–æ–º–∞–Ω–¥—ã /start –∏ /help
@dp.message(Command("start"))
async def start(message: types.Message):
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º–∏ –∏–∑ '–†–∏–∫ –∏ –ú–æ—Ä—Ç–∏'.",
        reply_markup=main_kb
    )
    logger.info(f"User {message.from_user.id} started the bot")


@dp.message(Command("help"))
async def help_command(message: types.Message):
    await message.answer(
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start - –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
        "/help - –ø–æ–º–æ—â—å\n"
        "üé≤ –†–∞–Ω–¥–æ–º–Ω—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂ - –ø–æ–ª—É—á–∏—Ç—å —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞\n"
        "‚≠êÔ∏è –ò–∑–±—Ä–∞–Ω–Ω–æ–µ - –≤–∞—à–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏"

    )
# –†–∞–Ω–¥–æ–º–Ω—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂
@dp.message(F.text == "üé≤ –†–∞–Ω–¥–æ–º–Ω—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂")
async def random_character_handler(message: types.Message):
    character = await get_random_character()
    if character:
        response = (
            f"üë§ –ò–º—è: {character['name']}\n"
            f"üíÄ –°—Ç–∞—Ç—É—Å: {character['status']}\n"
            f"üß¨ –í–∏–¥: {character['species']}\n"
            f"üöª –ü–æ–ª: {character['gender']}\n"
            f"üåç –ü—Ä–æ–∏—Å—Ö–æ–∂–¥–µ–Ω–∏–µ: {character['origin']['name']}\n"
            f"üìç –õ–æ–∫–∞—Ü–∏—è: {character['location']['name']}"
        )

        markup = InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(
                    text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞",
                    callback_data=f"save_{character['id']}"
                )]
            ]
        )

        await message.answer_photo(
            photo=character['image'],
            caption=response,
            reply_markup=markup
        )
    else:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ")


# –û–±—Ä–∞–±–æ—Ç–∫–∞ inline-–∫–Ω–æ–ø–∫–∏
@dp.callback_query(F.data.startswith("save_"))
async def save_character(callback: types.CallbackQuery, state: FSMContext):
    character_id = callback.data.split("_")[1]

    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
    character_name = callback.message.caption.split('\n')[0].replace("üë§ –ò–º—è: ", "")
    character_image = callback.message.photo[-1].file_id

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(
        character_id=character_id,
        character_name=character_name,
        character_image=character_image
    )

    await callback.message.answer("–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –ø–µ—Ä—Å–æ–Ω–∞–∂—É:")
    await state.set_state(FSMComment.wait_comment)
    await callback.answer()


# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
@dp.message(FSMComment.wait_comment)
async def save_comment(message: types.Message, state: FSMContext):
    data = await state.get_data()

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    add_favorite(
        user_id=message.from_user.id,
        character_id=data['character_id'],
        character_name=data['character_name'],
        character_image=data['character_image'],
        comment=message.text
    )

    await message.answer("‚úÖ –ü–µ—Ä—Å–æ–Ω–∞–∂ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ!")
    await state.clear()


# –ü–æ–∫–∞–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
@dp.message(F.text == "‚≠êÔ∏è –ò–∑–±—Ä–∞–Ω–Ω–æ–µ")
async def show_favorites(message: types.Message):
    favorites = get_favorites(message.from_user.id)

    if not favorites:
        await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π.")
        return

    for fav in favorites:
        name, image, comment = fav
        caption = f"üë§ {name}\nüí¨ –í–∞—à –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {comment if comment else '–Ω–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è'}"

        await message.answer_photo(
            photo=image,
            caption=caption
        )


async def main():
    logger.info("Starting bot...")
    try:
        await dp.start_polling(bot)
    except Exception as e:
        logger.error(f"Bot stopped with error: {e}")
    finally:
        await bot.session.close()


if __name__ == "__main__":
    asyncio.run(main())
